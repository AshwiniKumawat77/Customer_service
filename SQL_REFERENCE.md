# SQL Statements Reference

## Overview
This document contains all the SQL statements used in the custom save/update implementation with detailed explanations.

---

## 1. INSERT Customer Statement

### SQL Query
```sql
INSERT INTO customer 
(first_name, last_name, gender, date_of_birth, email, mobile, 
 pan_number, aadhaar_number, customer_uuid, status, created_date, updated_date) 
VALUES 
(:firstName, :lastName, :gender, :dateOfBirth, :email, :mobile, 
 :panNumber, :aadhaarNumber, :customerUuid, :status, :createdDate, :updatedDate)
```

### Parameters Explained

| Parameter Name | Database Column | Data Type | Constraints | Example |
|---|---|---|---|---|
| :firstName | first_name | VARCHAR(100) | NOT NULL | "John" |
| :lastName | last_name | VARCHAR(100) | NOT NULL | "Doe" |
| :gender | gender | VARCHAR(20) | NOT NULL | "M" |
| :dateOfBirth | date_of_birth | DATE | NOT NULL, PAST | "1990-05-15" |
| :email | email | VARCHAR(100) | NOT NULL, UNIQUE | "john@example.com" |
| :mobile | mobile | BIGINT | NOT NULL, UNIQUE | 9876543210 |
| :panNumber | pan_number | VARCHAR(10) | NOT NULL, UNIQUE | "ABCDE1234F" |
| :aadhaarNumber | aadhaar_number | VARCHAR(12) | NOT NULL, UNIQUE | "123456789012" |
| :customerUuid | customer_uuid | VARCHAR(36) | NOT NULL, UNIQUE | "550e8400-e29b-41d4-a716..." |
| :status | status | VARCHAR(20) | NOT NULL, DEFAULT 'PENDING_KYC' | "PENDING_KYC" |
| :createdDate | created_date | DATETIME | NOT NULL | "2026-02-15T10:30:00" |
| :updatedDate | updated_date | DATETIME | NOT NULL | "2026-02-15T10:30:00" |

### Java Method Signature
```java
@Modifying
@Query(value = CustomerConstants.INSERT_CUSTOMER, nativeQuery = true)
void saveCustomerNative(
    @Param("firstName") String firstName,
    @Param("lastName") String lastName,
    @Param("gender") String gender,
    @Param("dateOfBirth") LocalDate dateOfBirth,
    @Param("email") String email,
    @Param("mobile") Long mobile,
    @Param("panNumber") String panNumber,
    @Param("aadhaarNumber") String aadhaarNumber,
    @Param("customerUuid") String customerUuid,
    @Param("status") String status,
    @Param("createdDate") LocalDateTime createdDate,
    @Param("updatedDate") LocalDateTime updatedDate
);
```

### Java Call Example
```java
customer.setFirstName("John");
customer.setLastName("Doe");
customer.setGender("M");
customer.setDateOfBirth(LocalDate.of(1990, 5, 15));
customer.setEmail("john@example.com");
customer.setMobile(9876543210L);
customer.setPanNumber("ABCDE1234F");
customer.setAadhaarNumber("123456789012");
customer.setCustomerUuid(UUID.randomUUID().toString());
customer.setStatus(CustomerStatus.PENDING_KYC);
customer.setCreatedDate(LocalDateTime.now());
customer.setUpdatedDate(LocalDateTime.now());

customerRepository.saveCustomerNative(
    customer.getFirstName(),           // "John"
    customer.getLastName(),            // "Doe"
    customer.getGender(),              // "M"
    customer.getDateOfBirth(),         // LocalDate.of(1990, 5, 15)
    customer.getEmail(),               // "john@example.com"
    customer.getMobile(),              // 9876543210L
    customer.getPanNumber(),           // "ABCDE1234F"
    customer.getAadhaarNumber(),       // "123456789012"
    customer.getCustomerUuid(),        // "550e8400-e29b-41d4..."
    customer.getStatus().name(),       // "PENDING_KYC"
    customer.getCreatedDate(),         // LocalDateTime.now()
    customer.getUpdatedDate()          // LocalDateTime.now()
);
```

### What This SQL Does
- Creates a new customer record in the database
- Inserts exactly 12 columns with all required data
- Customer ID is auto-generated by the database (IDENTITY/AUTO_INCREMENT)
- Returns void (no result needed)

### Constraints Checked by Database
1. **UNIQUE** - email, mobile, pan_number, aadhaar_number cannot be duplicated
2. **NOT NULL** - all columns must have values
3. **Pattern Validation** - can be done in database CHECK constraints

---

## 2. UPDATE Customer Statement

### SQL Query
```sql
UPDATE customer SET 
    first_name = :firstName, 
    last_name = :lastName, 
    gender = :gender, 
    date_of_birth = :dateOfBirth, 
    email = :email, 
    mobile = :mobile, 
    pan_number = :panNumber, 
    aadhaar_number = :aadhaarNumber, 
    status = :status, 
    updated_date = :updatedDate 
WHERE customer_id = :customerId
```

### Parameters Explained

| Parameter Name | Database Column | Data Type | Purpose | Example |
|---|---|---|---|---|
| :customerId | customer_id | BIGINT | WHERE clause - identifies the row | 101 |
| :firstName | first_name | VARCHAR(100) | Update field | "John" |
| :lastName | last_name | VARCHAR(100) | Update field | "Doe" |
| :gender | gender | VARCHAR(20) | Update field | "M" |
| :dateOfBirth | date_of_birth | DATE | Update field | "1990-05-15" |
| :email | email | VARCHAR(100) | Update field | "john.new@example.com" |
| :mobile | mobile | BIGINT | Update field | 9876543210 |
| :panNumber | pan_number | VARCHAR(10) | Update field | "ABCDE1234F" |
| :aadhaarNumber | aadhaar_number | VARCHAR(12) | Update field | "123456789012" |
| :status | status | VARCHAR(20) | Update field | "ACTIVE" |
| :updatedDate | updated_date | DATETIME | Update field (timestamp) | "2026-02-15T11:00:00" |

### Java Method Signature
```java
@Modifying
@Query(value = CustomerConstants.UPDATE_CUSTOMER, nativeQuery = true)
int updateCustomerNative(
    @Param("customerId") Long customerId,
    @Param("firstName") String firstName,
    @Param("lastName") String lastName,
    @Param("gender") String gender,
    @Param("dateOfBirth") LocalDate dateOfBirth,
    @Param("email") String email,
    @Param("mobile") Long mobile,
    @Param("panNumber") String panNumber,
    @Param("aadhaarNumber") String aadhaarNumber,
    @Param("status") String status,
    @Param("updatedDate") LocalDateTime updatedDate
);
```

### Java Call Example
```java
Customer customer = customerRepository.findById(101L).orElse(null);
customer.setFirstName("John");
customer.setLastName("Doe");
customer.setGender("M");
customer.setDateOfBirth(LocalDate.of(1990, 5, 15));
customer.setEmail("john.new@example.com");
customer.setMobile(9876543210L);
customer.setPanNumber("ABCDE1234F");
customer.setAadhaarNumber("123456789012");
customer.setStatus(CustomerStatus.ACTIVE);
customer.setUpdatedDate(LocalDateTime.now());

int rowsAffected = customerRepository.updateCustomerNative(
    customer.getCustomerId(),          // 101L
    customer.getFirstName(),           // "John"
    customer.getLastName(),            // "Doe"
    customer.getGender(),              // "M"
    customer.getDateOfBirth(),         // LocalDate.of(1990, 5, 15)
    customer.getEmail(),               // "john.new@example.com"
    customer.getMobile(),              // 9876543210L
    customer.getPanNumber(),           // "ABCDE1234F"
    customer.getAadhaarNumber(),       // "123456789012"
    customer.getStatus().name(),       // "ACTIVE"
    customer.getUpdatedDate()          // LocalDateTime.now()
);

if (rowsAffected > 0) {
    log.info("Updated successfully: {} rows affected", rowsAffected);
} else {
    log.warn("No rows updated - customer ID may not exist");
}
```

### What This SQL Does
- Updates an existing customer record identified by customer_id
- Updates 10 customer data columns (all except customer_id and customer_uuid)
- Updates the timestamp to current time (for audit trail)
- Returns the number of rows affected (0 if no match, 1 if successful)

### Constraints Checked by Database
1. **WHERE Clause** - finds customer by primary key (customer_id)
2. **UNIQUE** - email, mobile, pan_number, aadhaar_number must remain unique (if changed)
3. **NOT NULL** - all columns must have values
4. **Immutable Fields** - customer_uuid cannot be changed (not in SET clause)

---

## 3. Related COUNT Queries

### COUNT by PAN Number
```sql
SELECT COUNT(*) FROM customer WHERE pan_number = :panNumber
```
- Returns: Number of customers with this PAN
- Used for: Duplicate check before insert/update
- Expected: 0 or 1 (should be 0 for new customer, 1 for existing)

### COUNT by Email
```sql
SELECT COUNT(*) FROM customer WHERE email = :email
```
- Returns: Number of customers with this email
- Used for: Duplicate check
- Expected: 0 or 1

### COUNT by Mobile
```sql
SELECT COUNT(*) FROM customer WHERE mobile = :mobile
```
- Returns: Number of customers with this mobile
- Used for: Duplicate check
- Expected: 0 or 1

### COUNT by Aadhaar
```sql
SELECT COUNT(*) FROM customer WHERE aadhaar_number = :aadhaarnumber
```
- Returns: Number of customers with this Aadhaar
- Used for: Duplicate check
- Expected: 0 or 1

---

## 4. Related FIND Queries

### FIND by PAN Number
```sql
SELECT * FROM customer WHERE pan_number = :panNumber
```
- Returns: Full customer record if found, empty if not
- Used for: KYC lookup, uniqueness verification

### FIND by Email
```sql
SELECT * FROM customer WHERE email = :email
```
- Returns: Full customer record if found, empty if not
- Used for: Login alternative, customer lookup

### FIND by Customer UUID
```sql
SELECT * FROM customer WHERE customer_uuid = :customerUuid
```
- Returns: Full customer record if found, empty if not
- Used for: Public API customer lookup (safe identifier)

### FIND by Customer ID
```sql
SELECT * FROM customer WHERE customer_id = :id
```
- Returns: Full customer record if found, empty if not
- Used for: Internal lookup by primary key

---

## 5. Transaction & Locking Behavior

### Isolation Level
- Default: `REPEATABLE_READ` (prevents dirty reads and non-repeatable reads)
- Ensures data consistency during concurrent operations

### Lock Behavior
- INSERT: Locks the inserted row
- UPDATE: Locks the WHERE clause rows
- Automatically released after COMMIT or ROLLBACK

### Rollback Conditions
```java
@Transactional(rollbackFor = Exception.class)
```
- Any Exception causes automatic rollback
- Ensures atomicity: either all changes succeed or all are rolled back

---

## 6. Database Index Recommendations

### For INSERT Performance
```sql
-- Indexes for uniqueness checks (prevent duplicates)
CREATE UNIQUE INDEX idx_email ON customer(email);
CREATE UNIQUE INDEX idx_pan ON customer(pan_number);
CREATE UNIQUE INDEX idx_mobile ON customer(mobile);
CREATE UNIQUE INDEX idx_aadhaar ON customer(aadhaar_number);
CREATE UNIQUE INDEX idx_uuid ON customer(customer_uuid);
```

### For SELECT Performance
```sql
-- Indexes for lookup queries
CREATE INDEX idx_status ON customer(status);
CREATE INDEX idx_created_date ON customer(created_date DESC);
CREATE INDEX idx_name ON customer(first_name, last_name);
```

---

## 7. Execution Flow Diagram

### INSERT Flow
```
1. Service validates all business rules
   ↓
2. Service populates Customer entity with all fields
   ↓
3. Service calls saveCustomerWithLogging(customer)
   ↓
4. Log: ENTER with UUID and name
   ↓
5. Log: DEBUG with all parameters
   ↓
6. Start timing
   ↓
7. Call customerRepository.saveCustomerNative(...all 12 params...)
   ↓
8. Spring Data prepares native SQL query with parameter binding
   ↓
9. Database executes INSERT statement
   ↓
10. Database validates constraints (UNIQUE, NOT NULL, etc)
    ↓
11. If success: Row inserted, auto-generated customer_id returned
    ↓
12. If failure: Exception thrown (DataIntegrityViolationException, etc)
    ↓
13. Stop timing
    ↓
14. Log: EXIT with execution time or ERROR with exception
    ↓
15. Return to caller with result
```

### UPDATE Flow
```
1. Service retrieves existing customer by ID
   ↓
2. Service validates all business rules
   ↓
3. Service updates Customer entity fields
   ↓
4. Service calls updateCustomerWithLogging(customer)
   ↓
5. Log: ENTER with customer ID and email
   ↓
6. Log: DEBUG with all parameters
   ↓
7. Start timing
   ↓
8. Call customerRepository.updateCustomerNative(...11 params...)
   ↓
9. Spring Data prepares native SQL query with parameter binding
   ↓
10. Database executes UPDATE statement
    ↓
11. Database validates constraints (UNIQUE, NOT NULL, etc)
    ↓
12. If success: Rows affected (usually 1)
    ↓
13. If failure: Exception thrown
    ↓
14. Stop timing
    ↓
15. Log: EXIT with rowsAffected or WARNING if rowsAffected = 0
    ↓
16. Log: ERROR if exception
    ↓
17. Return to caller with result
```

---

## 8. Parameter Binding & Security

### Safe Parameter Binding
```java
// Parameter binding prevents SQL injection
@Param("firstName") String firstName

// Named parameters in SQL
:firstName

// Example: If firstName = "John'; DROP TABLE customer; --"
// SQL becomes: ... first_name = 'John''; DROP TABLE customer; --'
// This is treated as a literal string, not SQL code
```

### Type Conversion
```java
LocalDate → java.sql.Date      // Date of birth
LocalDateTime → java.sql.Timestamp  // Created/Updated dates
Long → java.sql.BIGINT         // Mobile, ID
String → java.sql.VARCHAR      // All text fields
Enum.name() → String           // Status enum to string
```

---

## 9. Common Errors & Their Causes

### DataIntegrityViolationException
```
Cause: Duplicate email/PAN/mobile/aadhaar
SQL Error: Duplicate entry '...' for key 'email'
Solution: Check uniqueness before insert/update
```

### BadSqlGrammarException
```
Cause: Column name or syntax error in SQL
SQL Error: Unknown column 'first_name'
Solution: Verify table schema and column names
```

### DataAccessResourceFailureException
```
Cause: Database connection lost
SQL Error: Communications link failure
Solution: Check database server and connection pool
```

### ConstraintViolationException
```
Cause: NULL value in NOT NULL column
SQL Error: Column 'email' cannot be null
Solution: Validate all required fields before save
```

---

## 10. Testing SQL Statements Directly

### Test INSERT in MySQL/MariaDB
```sql
-- Verify table exists
DESCRIBE customer;

-- Test INSERT with specific values
INSERT INTO customer 
(first_name, last_name, gender, date_of_birth, email, mobile, 
 pan_number, aadhaar_number, customer_uuid, status, created_date, updated_date) 
VALUES 
('John', 'Doe', 'M', '1990-05-15', 'john@example.com', 9876543210,
 'ABCDE1234F', '123456789012', UUID(), 'PENDING_KYC', NOW(), NOW());

-- Verify insert
SELECT * FROM customer WHERE email = 'john@example.com';
```

### Test UPDATE in MySQL/MariaDB
```sql
-- Test UPDATE
UPDATE customer SET 
    first_name = 'Johnny',
    status = 'ACTIVE',
    updated_date = NOW()
WHERE customer_id = 1;

-- Verify update
SELECT * FROM customer WHERE customer_id = 1;

-- Check rows affected
SELECT ROW_COUNT();  -- Returns 1 if successful
```

---

## Summary

- **INSERT**: 12 parameters, returns void, creates new record
- **UPDATE**: 11 parameters (no UUID), returns int (rows affected)
- **Security**: Named parameter binding prevents SQL injection
- **Validation**: Database constraints enforce uniqueness and NOT NULL rules
- **Performance**: Indexes on unique and frequently queried columns essential
- **Transactions**: Automatic rollback on any exception ensures atomicity
